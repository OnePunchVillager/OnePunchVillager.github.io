[{"url":"/2018/10/26/反射/类的加载/","content":"# 类的加载\n\n## 概述\n\n> 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。\n\n- 加载 \n  - 就是指将class文件读入内存，并为之创建一个Class对象。\n  - 任何类被使用时系统都会建立一个Class对象。\n\n- 连接\n\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化 \n\n## 类的初始化时机\n\n- 创建类的实例\n\n- 访问类的静态变量，或者为静态变量赋值\n\n- 调用类的静态方法\n\n- 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n\n- 初始化某个类的子类\n\n- 直接使用java.exe命令来运行某个主类\n\n## 类加载器\n\n- 类加载器\n  - 负责将.class文件加载到内在中，并为之生成对应的Class对象。\n  - 虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。\n\n- 类加载器的组成\n  - Bootstrap ClassLoader 根类加载器\n  - Extension ClassLoader 扩展类加载器\n  - Sysetm ClassLoader 系统类加载器\n\n### 类加载器的作用\n\n- Bootstrap ClassLoader 根类加载器\n  - 也被称为引导类加载器，负责Java核心类的加载\n    - 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中\n\n- Extension ClassLoader 扩展类加载器\n\n  - 负责JRE的扩展目录中jar包的加载。\n\n    - 在JDK中JRE的lib目录下ext目录\n\n- Sysetm ClassLoader 系统类加载器\n\n  - 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径\n\n\n\n# 反射\n\n- JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n- 要想解剖一个类,必须先要获取到该类的**字节码文件对象**。而解剖使用的就是**Class类**中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.\n\n- Class类（类的成员分别对应一个对象）\n  - 属性 Field\n  - 构造方法 Constructor\n  - 成员方法 Method\n\n- 获取Class对象的方式\n\n  - A: Object类的getClass()方法\n  - B: 数据类型的静态属性class\n  - C: Class类中的静态方法（最好写全路径，会抛出ClassNotFoundException）\n\n    - public static Class forName(String className)\n  - 开发时一般用第三种\n\n    - 为什么呢?因为第三种是一个字符串，而不是一个具体的类名。这样我们就可以把这样的字符串配置到配置文件中。\n\n## 通过反射获取构造方法并使用\n\n- 获取构造方法\n\n  - `public Constructor[] getConstructors()`:所有公共构造方法\n  - `public Constructor[] getDeclaredConstructors()`:所有构造方法\n  - `public Constructor<T> getConstructor(Class<?>... parameterTypes)`\n    - 获取单个构造方法,但不能获取`private`的，会抛出`NoSuchMethodException`异常\n    - 参数表示的是：你要获取的构造方法的**构造参数个数**及对应的数据类型的class字节码文件对象\n  - ``public Constructor<T> getDeclaredConstructors(Class<?>... parameterTypes)``:\n    - 获取单个构造方法，可以获取所有构造方法，但是对于`private`方法，不能直接使用，会抛出 `IllegalAccessException`:非法的访问异常\n\n- 设置构造方法为可访问\n  - `public void setAccessible(boolean flag)`：\n    - 值为true则指示反射的对象在使用时应该取消Java语言访问检查。\n\n- 创建对象\n\n  - `public T newInstance(Object... initargs)`:使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。\n\n- 例获取公共构造器\n\n  ``` java\n  //Person(String name,int age)\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取构造器\n  Constructor con = c.getConstructor(String.class,int.class);\n  //构造对象\n  Object o = con.newInstance(\"Tom\",12);\n  ```\n\n- 访问私有构造器\n\n  ```java\n  //private Person(String name,int age)\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取构造器\n  Constructor con = c.getDeclaredConstructor(String.class,int.class);\n  //设置可以访问\n  con.canAccess(true);\n  //构造对象\n  Object o = con.newInstance(\"Tom\",12);\n  ```\n\n## 通过反射获取成员变量并使用\n\n- 获取所有成员\n  - `Field[] getFields()`:获取公共属性\n  - `Field[] getDeclaredFields()`:获取所有属性\n- 获取单个成员\n  - `Filed getFiled()`:获取单个公共属性\n  - `Field getDeclaredField()`：获取单个任意属性\n- 设置属性可访问\n  - `public void setAccessible(boolean flag)`\n- 修改成员的值\n  -  `public void set(Object obj,Object value)`:\n    - 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。\n\n- 例\n\n  ``` java\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取无参构造器\n  Constructor con = c.getDeclaredConstructor();\n  //通过无参构造器创建对象\n  Object o = con.newInstance();\n  //获取公共属性并赋值\n  Field nameField = c.getField(\"name\");\n  nameField.set(o, \"Tom\");\n  //获取私有属性\n  Field ageField = c.getDeclaredField(\"age\");\n  //设为可访问并赋值\n  ageField.setAccessible(true);\n  ageField.set(o, 18);\n  ```\n\n\n\n\n\n\n"}]