[{"title":"J2SE学习笔记-反射","url":"/2018/10/26/反射/类的加载/","content":"\n# 类的加载\n\n## 概述\n\n> 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。\n\n- 加载 \n  - 就是指将class文件读入内存，并为之创建一个Class对象。\n  - 任何类被使用时系统都会建立一个Class对象。\n\n- 连接\n\n  - 验证 是否有正确的内部结构，并和其他类协调一致\n\n  - 准备 负责为类的静态成员分配内存，并设置默认初始化值\n  - 解析 将类的二进制数据中的符号引用替换为直接引用\n\n- 初始化 \n\n## 类的初始化时机\n\n- 创建类的实例\n\n- 访问类的静态变量，或者为静态变量赋值\n\n- 调用类的静态方法\n\n- 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象\n\n- 初始化某个类的子类\n\n- 直接使用java.exe命令来运行某个主类\n\n## 类加载器\n\n- 类加载器\n  - 负责将.class文件加载到内在中，并为之生成对应的Class对象。\n  - 虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。\n\n- 类加载器的组成\n  - Bootstrap ClassLoader 根类加载器\n  - Extension ClassLoader 扩展类加载器\n  - Sysetm ClassLoader 系统类加载器\n\n### 类加载器的作用\n\n- Bootstrap ClassLoader 根类加载器\n  - 也被称为引导类加载器，负责Java核心类的加载\n    - 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中\n\n- Extension ClassLoader 扩展类加载器\n\n  - 负责JRE的扩展目录中jar包的加载。\n\n    - 在JDK中JRE的lib目录下ext目录\n\n- Sysetm ClassLoader 系统类加载器\n\n  - 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径\n\n\n\n# 反射\n\n- JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n- 要想解剖一个类,必须先要获取到该类的**字节码文件对象**。而解剖使用的就是**Class类**中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.\n\n- Class类（类的成员分别对应一个对象）\n  - 属性 Field\n  - 构造方法 Constructor\n  - 成员方法 Method\n\n- 获取Class对象的方式\n\n  - A: Object类的getClass()方法\n  - B: 数据类型的静态属性class\n  - C: Class类中的静态方法（**写全路径**，会抛出ClassNotFoundException）\n\n    - public static Class forName(String className)\n  - 开发时一般用第三种\n\n    - 为什么呢?因为第三种是一个字符串，而不是一个具体的类名。这样我们就可以把这样的字符串配置到配置文件中。\n\n## 通过反射获取构造方法并使用\n\n- 获取构造方法\n\n  - `public Constructor[] getConstructors()`:所有公共构造方法\n  - `public Constructor[] getDeclaredConstructors()`:所有构造方法\n  - `public Constructor<T> getConstructor(Class<?>... parameterTypes)`\n    - 获取单个构造方法,但不能获取`private`的，会抛出`NoSuchMethodException`异常\n    - 参数表示的是：你要获取的构造方法的**构造参数个数**及对应的数据类型的class字节码文件对象\n  - ``public Constructor<T> getDeclaredConstructors(Class<?>... parameterTypes)``:\n    - 获取单个构造方法，可以获取所有构造方法，但是对于`private`方法，不能直接使用，会抛出 `IllegalAccessException`:非法的访问异常\n\n- 设置构造方法为可访问\n  - `public void setAccessible(boolean flag)`：\n    - 值为true则指示反射的对象在使用时应该取消Java语言访问检查。\n\n- 创建对象\n\n  - `public T newInstance(Object... initargs)`:使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。\n\n- 例获取公共构造器\n\n  ``` java\n  //Person(String name,int age)\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取构造器\n  Constructor con = c.getConstructor(String.class,int.class);\n  //构造对象\n  Object o = con.newInstance(\"Tom\",12);\n  ```\n\n- 访问私有构造器\n\n  ```java\n  //private Person(String name,int age)\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取构造器\n  Constructor con = c.getDeclaredConstructor(String.class,int.class);\n  //设置可以访问\n  con.canAccess(true);\n  //构造对象\n  Object o = con.newInstance(\"Tom\",12);\n  ```\n\n## 通过反射获取成员变量并使用\n\n- 获取所有成员\n  - `Field[] getFields()`:获取公共属性\n  - `Field[] getDeclaredFields()`:获取所有属性\n- 获取单个成员\n  - `Filed getFiled()`:获取单个公共属性\n  - `Field getDeclaredField()`：获取单个任意属性\n- 设置属性可访问\n\n  - `public void setAccessible(boolean flag)`\n- 修改成员的值\n  -  `public void set(Object obj,Object value)`:\n    -  将指定对象变量上此 Field 对象表示的字段设置为指定的新值。\n\n- 注：**从父类继承来的属性是获取不到的**\n\n- 例\n\n  ``` java\n  //获取Class对象\n  Class c = Class.forName(\"test.Person\");\n  //获取无参构造器\n  Constructor con = c.getDeclaredConstructor();\n  //通过无参构造器创建对象\n  Object o = con.newInstance();\n  //获取公共属性并赋值\n  Field nameField = c.getField(\"name\");\n  nameField.set(o, \"Tom\");\n  //获取私有属性\n  Field ageField = c.getDeclaredField(\"age\");\n  //设为可访问并赋值\n  ageField.setAccessible(true);\n  ageField.set(o, 18);\n  ```\n\n## 通过反射获取成员方法并使用\n\n- 获取所有方法\n  - `Method[] getMethods()` ：获取**自己的包括父类继承来的**公共方法\n  - `Method[] getDeclaredMethods()`： 获取**自己的**所有的方法\n\n- 获取单个方法\n\n  - `public Method getMethod(String name,Class<?>... parameterTypes)`：\n\n    - 获取自己的包括父类继承来的公共方法\n\n    - 第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型\n\n  - `public Method getDecalredMethod(String name,Class<?>... parameterTypes)`：\n\n    - 获取自己的所有方法\n\n- 设置方法可访问\n\n  - ``public void setAccessible(boolean flag)`\n\n- 使用方法\n\n  - `public Object invoke(Object obj,Object... args)`:\n    - 返回值是Object接收,第一个参数表示对象是谁，第二参数表示调用该方法的实际参数\n\n- 例：\n\n  ``` java\n  Class ca = Class.forName(\"test.B\");\n  Object o = ca.newInstance();\n  //获取无参非静态无返回值方法并执行\n  Method m = ca.getMethod(\"show\");\n  m.invoke(o);\n  //获取带参静态有返回值方法并执行\n  Method m2 = ca.getDeclaredMethod(\"print\", String.class);\n  m2.setAccessible(true);\n  Object result = m2.invoke(o, \"hello\");\n  ```\n\n## 综合运用\n\n- 模拟通过反射运行配置文件\n\n  - 如果没有反射，只能通过修改代码实现功能的切换，有了反射，修改配置文件即可\n\n  - 设配置文件的格式为：\n\n    ``` \n    className = XXX\n    methodName = XXX\n    ...//之后能有参数个数，参数类型，参数值等信息\n    ```\n\n  - 以实现无参方法为例\n\n    ``` java\n    //和Properities类结合，读取配置信息\n    Properties p = new Properties();\n    FileInputStream fis = new FileInputStream(\"E:\\\\class.txt\");\n    p.load(fis);\n    //构造对象\n    String className = p.getProperty(\"className\");\n    Class c = Class.forName(className);\n    Object o = c.newInstance();\n    //执行方法\n    String methodName = p.getProperty(\"methodName\");\n    Method m = c.getMethod(methodName);\n    m.invoke(o);\n    ```\n\n- 模拟越过泛型检查\n\n  - 因为泛型其实只是一个编译机制，编译后是会被擦除的，对于没有通过extends通配符限定的泛型类型，编译后是Object类型的，所以是可以存入任意类型的，只不过在编译时会进行检查。通过反射，强制将不同类型的数据插入。\n\n    ``` java\n    //对于泛型为Integer的ArrayList，强制add一个String类型数据\n    ArrayList<Integer> a = new ArrayList<Integer>();\n    Class c = ArrayList.class;\n    Method m = c.getMethod(\"add\", Object.class);\n    m.invoke(a, \"hello\");\n    //我们已经加进去了但是这里还是会报错，很有意思\n    String s = a.get(0);//cannot convert from Integer to String\n    ```\n\n- 写一个方法\n\n  - public void setProperty(Object obj, String propertyName, Object value){}\n\n  - 此方法可将obj对象中名为propertyName的属性的值设置为value。\n\n    ``` java\n    public static void setProperty(Object obj, String propertyName, Object value) throws Exception{\n    \t//通过getClass获取Class对象\n    \tClass c = obj.getClass();\n    \t//获取属性\n    \tField f = c.getDeclaredField(propertyName);\n    \t//赋值\n        f.setAccessible(true);\n    \tf.set(obj, value);\n    }\n    ```\n\n## 动态代理\n\n- 需求：需要在原本的类上增加一些通用新功能，但是直接修改代码的话就破坏了开闭原则，拓展性很低，而且如果方法很多，需要修改的代码就很多，所以就让别的类来帮忙实现。\n\n- 代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。\n\n  - 如房产中介，找房的工作他帮你实现，你只负责买房。\n\n- 动态代理：在程序运行过程中产生的对象\n\n  - 而程序运行过程中产生对象其实就是通过反射来实现的\n\n- 在Java中`java.lang.reflect`包下提供了一个Proxy类和一个`InvocationHandler`接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。有更强大的代理`cglib`\n\n- Proxy类中的方法创建动态代理类对象\n  - `public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`：返回一个指定接口的代理类实例\n\n    返回一个指定接口的代理类实例\n\n  - 返回的Object就是需被代理的类，最终会调用`InvocationHandler`的方法\n\n- InvocationHandler：调用处理程序接口\n\n  - `Object invoke(Object proxy,Method method,Object[] args)`：在代理实例上处理方法调用并返回结果。\n\n    - 参数：\n\n      - proxy：需要代理的类实例\n\n      - method：需要代理的类需实现的方法 \n\n      - args：方法需要的参数\n\n- 例:模拟实现一个在执行方法前执行权限校验，执行方法后执行日志记录的代理\n\n    ``` java\n    //有这样一个用于实现增删改查的接口\n    public interface UserDao {\n    \tpublic abstract void add();\n    \tpublic abstract void delete();\n    \tpublic abstract void update();\n    \tpublic abstract void find();\n    }\n    \n    //有一个实现类\n    public class UserDaoImpl implements UserDao {\n    \tpublic void add() {\n    \t\tSystem.out.println(\"添加功能\");\n    \t}\n    \tpublic void delete() {\n    \t\tSystem.out.println(\"删除功能\");\n    \t}\n    \tpublic void update() {\n    \t\tSystem.out.println(\"修改功能\");\n    \t}\n    \tpublic void find() {\n    \t\tSystem.out.println(\"查找功能\");\n    \t}\n    }\n    \n    //首先实现一个代理处理程序\n    public class MyInvocationHandler implements InvocationHandler {\n    \tprivate Object target; // 目标对象\n    \n    \tpublic MyInvocationHandler(Object target) {\n    \t\tthis.target = target;\n    \t}\n    \n    \tpublic Object invoke(Object proxy, Method method, Object[] args)\n    \t\t\tthrows Throwable {\n    \t\tSystem.out.println(\"权限校验\");\n    \t\tObject result = method.invoke(target, args);\n    \t\tSystem.out.println(\"日志记录\");\n    \t\treturn result; // 返回的是代理对象的返回值\n    \t}\n    }\n    \n    //使用代理类代理\n    public class ProxyDemo {\n    \tpublic static void main(String[] args) {\n    \t\t//创建需代理的对象\n    \t\tUserDao ud = new UserDaoImpl();\n    \t\t//创建代理\n    \t\tInvocationHandler handler = new MyInvocationHandler(ud);\n    \t\tUserDao ud2 = (UserDao)Proxy.newProxyInstance(ud.getClass().getClassLoader(), \n    \t\t\t\tud.getClass().getInterfaces(), handler);\n    \t\t//这样就可以用代理类实现功能了\n    \t\tud2.add();\n    \t\tud2.delete();\n    \t}\n    }\n    ```\n\n​    \n\n\n\n\n\n\n"}]